using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

using Nemerle;
using Nemerle.Extensions;
using Nemerle.Imperative;

namespace LinqToDB_Temp.Extensions
{
	using Common;
	using MacroInternal;
	using MacroInternal.Extensions;

	public module LinqExpressionExtensions
	{
		#region IsConstant

		public IsConstantable(this type : Type) : bool
		{
			match (Type.GetTypeCode(type.ToUnderlying()))
			{
				| Byte    | Int16  | Int32  | Int64
				| SByte   | UInt16 | UInt32 | UInt64
				| Decimal | Double | Single | Boolean
				| String
				| Char    => true
				| _       => false
			}
		}

		#endregion

		#region EqualsTo

		public EqualsTo(this expr1 : Expression, expr2 : Expression, queryableAccessorDic : Dictionary[Expression,Func[Expression,IQueryable]]) : bool
		{
			EqualsTo(expr1, expr2, HashSet(), queryableAccessorDic) : bool
		}

		public EqualsTo(expr1 : Expression, expr2 : Expression, visited : HashSet[Expression], queryableAccessorDic : Dictionary[Expression,Func[Expression,IQueryable]]) : bool
		{
			if (expr1 === expr2)
				true
			else if (expr1 == null || expr2 == null || expr1.NodeType != expr2.NodeType || expr1.Type != expr2.Type)
				false
			else match (expr1.NodeType)
			{
				| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
				| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
				| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
				| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
				| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
				| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
				| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
				| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
				| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
				| ExpressionType.Subtract
				| ExpressionType.SubtractAssign
				| ExpressionType.SubtractChecked =>

					def e1 = expr1 :> BinaryExpression;
					def e2 = expr2 :> BinaryExpression;

					e1.Method == e2.Method &&
					EqualsTo(e1.Conversion, e2.Conversion, visited, queryableAccessorDic) &&
					EqualsTo(e1.Left,       e2.Left,       visited, queryableAccessorDic) &&
					EqualsTo(e1.Right,      e2.Right,      visited, queryableAccessorDic)

				| ExpressionType.ArrayLength
				| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
				| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
				| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
				| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
				| ExpressionType.Decrement
				| ExpressionType.UnaryPlus       =>

					def e1 = expr1 :> UnaryExpression;
					def e2 = expr2 :> UnaryExpression;

					e1.Method == e2.Method && EqualsTo(e1.Operand, e2.Operand, visited, queryableAccessorDic)

				| ExpressionType.Call            =>

					def e1 = expr1 :> MethodCallExpression;
					def e2 = expr2 :> MethodCallExpression;

					when (e1.Arguments.Count != e2.Arguments.Count || e1.Method != e2.Method)
						return false;

					when (queryableAccessorDic.Count > 0)
					{
						mutable func;

						when (queryableAccessorDic.TryGetValue(expr1, out func))
							return EqualsTo(func(expr1).Expression, func(expr2).Expression, visited, queryableAccessorDic);
					}

					when (!EqualsTo(e1.Object, e2.Object, visited, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!EqualsTo(e1.Arguments[i], e2.Arguments[i], visited, queryableAccessorDic))
							return false;

					true

				| ExpressionType.Conditional     =>

					def e1 = expr1 :> ConditionalExpression;
					def e2 = expr2 :> ConditionalExpression;

					EqualsTo(e1.Test,    e2.Test,    visited, queryableAccessorDic) &&
					EqualsTo(e1.IfTrue,  e2.IfTrue,  visited, queryableAccessorDic) &&
					EqualsTo(e1.IfFalse, e2.IfFalse, visited, queryableAccessorDic);

				| ExpressionType.Constant        =>

					def e1 = expr1 :> ConstantExpression;
					def e2 = expr2 :> ConstantExpression;

					if (e1.Value == null && e2.Value == null)
						true
					else if (IsConstantable(e1.Type))
						Equals(e1.Value, e2.Value)
					else if (e1.Value == null || e2.Value == null)
						false
					else if (e1.Value is IQueryable)
					{
						def eq1 = (e1.Value :> IQueryable).Expression;
						def eq2 = (e2.Value :> IQueryable).Expression;

						if (!visited.Contains(eq1))
						{
							_ = visited.Add(eq1);
							EqualsTo(eq1, eq2, visited, queryableAccessorDic);
						}
						else
							true
					}
					else
						true;

				| ExpressionType.Invoke          =>

					def e1 = expr1 :> InvocationExpression;
					def e2 = expr2 :> InvocationExpression;

					when (e1.Arguments.Count != e2.Arguments.Count || !EqualsTo(e1.Expression, e2.Expression, visited, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!EqualsTo(e1.Arguments[i], e2.Arguments[i], visited, queryableAccessorDic))
							return false;

					true;

				| ExpressionType.Lambda          =>

					def e1 = expr1 :> LambdaExpression;
					def e2 = expr2 :> LambdaExpression;

					when (e1.Parameters.Count != e2.Parameters.Count || !EqualsTo(e1.Body, e2.Body, visited, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Parameters.Count; i++)
						when (!EqualsTo(e1.Parameters[i], e2.Parameters[i], visited, queryableAccessorDic))
							return false;

					true;

				| ExpressionType.ListInit        =>

					def e1 = expr1 :> ListInitExpression;
					def e2 = expr2 :> ListInitExpression;

					when (e1.Initializers.Count != e2.Initializers.Count || !EqualsTo(e1.NewExpression, e2.NewExpression, visited, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Initializers.Count; i++)
					{
						def i1 = e1.Initializers[i];
						def i2 = e2.Initializers[i];

						when (i1.Arguments.Count != i2.Arguments.Count || i1.AddMethod != i2.AddMethod)
							return false;

						for (mutable j = 0; j < i1.Arguments.Count; j++)
							when (!EqualsTo(i1.Arguments[j], i2.Arguments[j], visited, queryableAccessorDic))
								return false;
					}

					true;

				| ExpressionType.MemberAccess    =>

					def e1 = expr1 :> MemberExpression;
					def e2 = expr2 :> MemberExpression;

					if (e1.Member == e2.Member)
					{
						when (e1.Expression === e2.Expression)
						{
							when (queryableAccessorDic.Count > 0)
							{
								mutable func;

								when (queryableAccessorDic.TryGetValue(expr1, out func))
									return EqualsTo(func(expr1).Expression, func(expr2).Expression, visited, queryableAccessorDic);
							}
						}

						EqualsTo(e1.Expression, e2.Expression, visited, queryableAccessorDic);
					}
					else
						false

				| ExpressionType.MemberInit      =>

					def e1 = expr1 :> MemberInitExpression;
					def e2 = expr2 :> MemberInitExpression;

					when (e1.Bindings.Count != e2.Bindings.Count || !EqualsTo(e1.NewExpression, e2.NewExpression, visited, queryableAccessorDic))
						return false;

					def compareBindings (b1 : MemberBinding, b2 : MemberBinding) : bool
					{
						when (b1 === b2)
							return true;

						when (b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member)
							return false;

						match (b1.BindingType)
						{
							| MemberBindingType.Assignment =>
								(b1 :> MemberAssignment).Expression.EqualsTo((b2 :> MemberAssignment).Expression, queryableAccessorDic)

							| MemberBindingType.ListBinding => 
								def ml1 = b1 :> MemberListBinding;
								def ml2 = b2 :> MemberListBinding;

								when (ml1.Initializers.Count != ml2.Initializers.Count)
									return false;

								for (mutable i = 0; i < ml1.Initializers.Count; i++)
								{
									def ei1 = ml1.Initializers[i];
									def ei2 = ml2.Initializers[i];

									when (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)
										return false;

									for (mutable j = 0; j < ei1.Arguments.Count; j++)
										when (!EqualsTo(ei1.Arguments[j], ei2.Arguments[j], visited, queryableAccessorDic))
											return false;
								}

								true;

							| MemberBindingType.MemberBinding =>
								def mm1 = b1 :> MemberMemberBinding;
								def mm2 = b2 :> MemberMemberBinding;

								when (mm1.Bindings.Count != mm2.Bindings.Count)
									return false;

								for (mutable i = 0; i < mm1.Bindings.Count; i++)
									when (!compareBindings(mm1.Bindings[i], mm2.Bindings[i]))
										return false;

								true;
						}
					}

					for (mutable i = 0; i < e1.Bindings.Count; i++)
					{
						def b1 = e1.Bindings[i];
						def b2 = e2.Bindings[i];

						when (!compareBindings(b1, b2))
							return false;
					}

					true

				| ExpressionType.New             =>

					def e1 = expr1 :> NewExpression;
					def e2 = expr2 :> NewExpression;

					when (e1.Arguments.Count != e2.Arguments.Count)
						return false;

					when (e1.Members == null && e2.Members != null)
						return false;

					when (e1.Members != null && e2.Members == null)
						return false;

					when (e1.Constructor != e2.Constructor)
						return false;

					when (e1.Members != null)
					{
						when (e1.Members.Count != e2.Members.Count)
							return false;

						for (mutable i = 0; i < e1.Members.Count; i++)
							when (e1.Members[i] != e2.Members[i])
								return false;
					}

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!EqualsTo(e1.Arguments[i], e2.Arguments[i], visited, queryableAccessorDic))
							return false;

					true;

				| ExpressionType.NewArrayBounds
				| ExpressionType.NewArrayInit    =>

					def e1 = expr1 :> NewArrayExpression;
					def e2 = expr2 :> NewArrayExpression;

					when (e1.Expressions.Count != e2.Expressions.Count)
						return false;

					for (mutable i = 0; i < e1.Expressions.Count; i++)
						when (!EqualsTo(e1.Expressions[i], e2.Expressions[i], visited, queryableAccessorDic))
							return false;

					true;

				| ExpressionType.Parameter       =>

					def e1 = expr1 :> ParameterExpression;
					def e2 = expr2 :> ParameterExpression;
					e1.Name == e2.Name;

				| ExpressionType.TypeEqual
				| ExpressionType.TypeIs          =>

					def e1 = expr1 :> TypeBinaryExpression;
					def e2 = expr2 :> TypeBinaryExpression;
					e1.TypeOperand == e2.TypeOperand && EqualsTo(e1.Expression, e2.Expression, visited, queryableAccessorDic);

				| ExpressionType.Block           =>

					def e1 = expr1 :> BlockExpression;
					def e2 = expr2 :> BlockExpression;

					for (mutable i = 0; i < e1.Expressions.Count; i++)
						when (!EqualsTo(e1.Expressions[i], e2.Expressions[i], visited, queryableAccessorDic))
							return false;

					for (mutable i = 0; i < e1.Variables.Count; i++)
						when (!EqualsTo(e1.Variables[i], e2.Variables[i], visited, queryableAccessorDic))
							return false;

					true;

				| ExpressionType.Extension when expr1.CanReduce && expr2.CanReduce =>

					EqualsTo(expr1.Reduce(), expr2.Reduce(), visited, queryableAccessorDic)

				| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
				| ExpressionType.Extension     | ExpressionType.Goto            | ExpressionType.Index           | ExpressionType.Label
				| ExpressionType.Loop          | ExpressionType.Switch
				| ExpressionType.Try
				| ExpressionType.Throw           => throw InvalidOperationException()
			}
		}

		#endregion

		#region Path

		ConvertTo(expr : Expression, type : Type) : Expression
		{
			Expression.Convert(expr, type);
		}

		Path[T](source : IEnumerable[T], _visited : HashSet[Expression], pathExpr : Expression, property : MethodInfo, func : T * Expression -> void) : void
			where T : class
		{
			def prop = Expression.Property(pathExpr, property);
			mutable i = 0;
			foreach (item in source)
				func(item, Expression.Call(prop, infoof(ReadOnlyCollection[T].Item), array[ Expression.Constant({ i++; i }) ]));
		}

		Path(expr : Expression, visited : HashSet[Expression], pathExpr : Expression, property : MethodInfo, func : Expression * Expression -> void) : void
		{
			Path(expr, visited, Expression.Property(pathExpr, property), func);
		}

		public Path(this expr : Expression, pathExpr : Expression, func : Expression * Expression -> void) : void
		{
			Path(expr, HashSet.[Expression](), pathExpr, func);
		}

		Path(expr : Expression, visited : HashSet[Expression], pathExpr : Expression, func : Expression * Expression -> void) : void
		{
			when (expr != null)
			{
				def pathExpr = match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => path BinaryExpression      members (Left,       Conversion, Right);
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => path UnaryExpression       members (Operand)
					| ExpressionType.Call            => path MethodCallExpression  members (Object,     Arguments)
					| ExpressionType.Conditional     => path ConditionalExpression members (Test,       IfTrue, IfFalse)
					| ExpressionType.Invoke          => path InvocationExpression  members (Expression, Arguments)
					| ExpressionType.Lambda          => path LambdaExpression      members (Body,       Parameters)
					| ExpressionType.MemberAccess    => path MemberExpression      members (Expression)
					| ExpressionType.New             => path NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => path NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => path NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => path TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => path BlockExpression       members (Variables,  Expressions)
					| ExpressionType.Parameter       => ConvertTo(pathExpr, typeof(ParameterExpression))
					| ExpressionType.Constant        =>
					
						def pe = ConvertTo(pathExpr, typeof(ConstantExpression));
						def e  = expr :> ConstantExpression;

						match (e.Value)
						{
							| iq is IQueryable when !visited.Contains(iq.Expression) =>
							
								_ = visited.Add(iq.Expression);

								def p = Expression.Property(pe, propertyof(ConstantExpression.Value));
								def p = ConvertTo(p, typeof(IQueryable));
								Path(iq.Expression, visited, p, propertyof(IQueryable.Expression), func);

							| _ => ()
						}

						pe

					| ExpressionType.ListInit        =>

						path ListInitExpression members (
							NewExpression,
							Path(e.Initializers, visited, p, infoof(ListInitExpression.Initializers), (ex,p) => Path(ex.Arguments, visited, p, infoof(ElementInit.Arguments), func)))

					| ExpressionType.MemberInit      =>

						def modify(b : MemberBinding, pinf : Expression)
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment =>
									Path(
										(b :> MemberAssignment).Expression,
										visited,
										ConvertTo(pinf, typeof(MemberAssignment)),
										infoof(MemberAssignment.Expression),
										func);

								| MemberBindingType.ListBinding =>
									Path(
										(b :> MemberListBinding).Initializers,
										visited,
										ConvertTo(pinf, typeof(MemberListBinding)),
										infoof(MemberListBinding.Initializers),
										(p,psi) => Path(p.Arguments, visited, psi, infoof(ElementInit.Arguments), func));

								| MemberBindingType.MemberBinding =>
									Path(
										(b :> MemberMemberBinding).Bindings,
										visited,
										ConvertTo(pinf, typeof(MemberMemberBinding)),
										infoof(MemberMemberBinding.Bindings),
										modify);
							}
						}

						path MemberInitExpression members (
							Path(e.NewExpression, visited, p, infoof(MemberInitExpression.NewExpression), func),
							Path(e.Bindings,      visited, p, infoof(MemberInitExpression.Bindings),      modify));

					| ExpressionType.Extension when expr is DefaultValueExpression => ConvertTo(pathExpr, typeof(DefaultValueExpression))
					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Extension     | ExpressionType.Goto            | ExpressionType.Index           | ExpressionType.Label
					| ExpressionType.Loop          | ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => throw InvalidOperationException()
				}

				func(expr, pathExpr);
			}
		}

		#endregion

		#region Visit

		static Visit[T](source : IEnumerable[T], func : T -> void) : void
		{
			foreach (item in source)
				func(item);
		}

		public static Visit(this expr : Expression, func : Action[Expression]) : void
		{
			Visit(expr, func.Invoke)
		}

		public static Visit(this expr : Expression, func : Expression -> void) : void
		{
			when (expr != null)
			{
				match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => visit BinaryExpression      members (Conversion,    Left, Right)
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => visit UnaryExpression       members (Operand)
					| ExpressionType.Call            => visit MethodCallExpression  members (Object,        Arguments)
					| ExpressionType.Conditional     => visit ConditionalExpression members (Test,          IfTrue, IfFalse)
					| ExpressionType.Invoke          => visit InvocationExpression  members (Expression,    Arguments)
					| ExpressionType.Lambda          => visit LambdaExpression      members (Body,          Parameters)
					| ExpressionType.MemberAccess    => visit MemberExpression      members (Expression)
					| ExpressionType.New             => visit NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => visit NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => visit NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => visit TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => visit BlockExpression       members (Expressions,   Variables)
					| ExpressionType.ListInit        => visit ListInitExpression    members (NewExpression, Visit(e.Initializers, ex => Visit(ex.Arguments, func)))
					| ExpressionType.MemberInit      =>

						def modify(b : MemberBinding)
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment    => Visit((b :> MemberAssignment). Expression,   func);
								| MemberBindingType.ListBinding   => Visit((b :> MemberListBinding).Initializers, p => Visit(p.Arguments, func));
								| MemberBindingType.MemberBinding => Visit((b :> MemberMemberBinding).Bindings,   modify);
							}
						};

						visit MemberInitExpression members (NewExpression, Visit(e.Bindings, modify));

					// !!!!!!!!!!!!!!!!| x when x == (ChangeTypeExpression.ChangeTypeType : ExpressionType) =>
					//	Visit(((ChangeTypeExpression)expr).Expression,  func); break;

					| ExpressionType.Extension
					| ExpressionType.Constant
					| ExpressionType.Parameter       => ()
					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Goto          | ExpressionType.Index           | ExpressionType.Label           | ExpressionType.Loop
					| ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => throw InvalidOperationException()
				}

				func(expr);
			}
		}

		static Visit[T](source : IEnumerable[T], func : T -> bool) : void
		{
			foreach (item in source)
				_ = func(item);
		}

		public static Visit(this expr : Expression, func : Func[Expression,bool]) : void
		{
			Visit(expr, func.Invoke)
		}

		public static Visit(this expr : Expression, func : Expression -> bool) : void
		{
			when (expr != null && func(expr))
			{
				match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => visit BinaryExpression     members (Left, Conversion, Right)
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => visit UnaryExpression       members (Operand)
					| ExpressionType.Call            => visit MethodCallExpression  members (Object,        Arguments)
					| ExpressionType.Conditional     => visit ConditionalExpression members (Test,          IfTrue, IfFalse);
					| ExpressionType.Invoke          => visit InvocationExpression  members (Expression,    Arguments)
					| ExpressionType.Lambda          => visit LambdaExpression      members (Body,          Parameters)
					| ExpressionType.MemberAccess    => visit MemberExpression      members (Expression)
					| ExpressionType.New             => visit NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => visit NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => visit NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => visit TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => visit BlockExpression       members (Expressions,   Variables)
					| ExpressionType.ListInit        => visit ListInitExpression    members (NewExpression, Visit(e.Initializers,  ex => Visit(ex.Arguments, func)))
					| ExpressionType.MemberInit      =>

						def modify(b) : bool
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment    => Visit((b :> MemberAssignment)   .Expression,   func);
								| MemberBindingType.ListBinding   => Visit((b :> MemberListBinding)  .Initializers, p => Visit(p.Arguments, func));
								| MemberBindingType.MemberBinding => Visit((b :> MemberMemberBinding).Bindings,     modify);
							}

							true
						}

						visit MemberInitExpression members (NewExpression, Visit(e.Bindings, modify));

					//case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
					//	Visit(((ChangeTypeExpression)expr).Expression,  func);
					//	break;
					| ExpressionType.Extension
					| ExpressionType.Constant
					| ExpressionType.Parameter       => ()
					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Goto          | ExpressionType.Index           | ExpressionType.Label           | ExpressionType.Loop
					| ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => throw InvalidOperationException()
				}
			}
		}

		#endregion

		#region Find

		static Find[T](source : IEnumerable[T], func : T -> Expression) : Expression
		{
			foreach (item in source)
			{
				def ex = func(item);
				when (ex != null)
					return ex;
			}

			null
		}

		static Find[T](source : IEnumerable[T], func : Expression -> bool) : Expression
			where T : Expression
		{
			foreach (item in source)
			{
				def f = Find(item, func);
				when (f != null)
					return f;
			}

			null
		}

		public static Find(this expr : Expression, func : Expression -> bool) : Expression
		{
			if (expr == null || func(expr))
				expr
			else
				match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => find BinaryExpression      members (Conversion, Left, Right);
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => find UnaryExpression       members (Operand)
					| ExpressionType.Call            => find MethodCallExpression  members (Object,     Arguments)
					| ExpressionType.Conditional     => find ConditionalExpression members (Test,       IfTrue, IfFalse)
					| ExpressionType.Invoke          => find InvocationExpression  members (Expression, Arguments)
					| ExpressionType.Lambda          => find LambdaExpression      members (Body,       Parameters)
					| ExpressionType.MemberAccess    => find MemberExpression      members (Expression)
					| ExpressionType.New             => find NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => find NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => find NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => find TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => find BlockExpression       members (Expressions, Variables)
					| ExpressionType.ListInit        => find ListInitExpression    members (NewExpression, Find(e.Initializers,  ex => Find(ex.Arguments, func)))
					| ExpressionType.MemberInit      =>

						def modify(b : MemberBinding) : Expression
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment    => Find((b :> MemberAssignment)   .Expression,   func);
								| MemberBindingType.ListBinding   => Find((b :> MemberListBinding)  .Initializers, p => Find(p.Arguments, func));
								| MemberBindingType.MemberBinding => Find((b :> MemberMemberBinding).Bindings,     modify);
								| _ => null
							}
						}

						find MemberInitExpression members (NewExpression, Find(e.Bindings, modify))

					////////////case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
					//	return Find(((ChangeTypeExpression)expr).Expression, func);

					| ExpressionType.Extension
					| ExpressionType.Constant
					| ExpressionType.Parameter
					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Goto          | ExpressionType.Index           | ExpressionType.Label           | ExpressionType.Loop
					| ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => null
				}
		}

		#endregion

		#region Transform

		static TransformT[T](source : ICollection[T], func : T -> T) : IEnumerable[T]
			where T : class
		{
			mutable modified = false;
			def @list = List();

			foreach (item in source)
			{
				def e = func(item);
				@list.Add(e);
				modified = modified || e !== item;
			}

			if (modified) @list else source
		}

		static Transform[T](source : ICollection[T], func : Expression -> Expression) : IEnumerable[T]
			where T : Expression
		{
			mutable modified = false;
			def @list = List();

			foreach (item in source)
			{
				def e = Transform(item, func);
				@list.Add(e :> T);
				modified = modified || e !== item;
			}

			if (modified) @list else source
		}

		public static Transform(this expr : Expression, func : Expression -> Expression) : Expression
		{
			if (expr == null)
				null
			else
				match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => transform BinaryExpression      members (Left, Transform(e.Conversion, func) :> LambdaExpression, Right)
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => transform UnaryExpression       members (Operand)
					| ExpressionType.Call            => transform MethodCallExpression  members (Object,     Arguments)
					| ExpressionType.Conditional     => transform ConditionalExpression members (Test,       IfTrue,  IfFalse)
					| ExpressionType.Invoke          => transform InvocationExpression  members (Expression, Arguments)
					| ExpressionType.MemberAccess    => transform MemberExpression      members (Expression)
					| ExpressionType.New             => transform NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => transform NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => transform NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => transform TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => transform BlockExpression       members (Variables, Expressions)
					| ExpressionType.Extension
					| ExpressionType.Constant
					| ExpressionType.Parameter       => func(expr)
					| ExpressionType.Lambda          =>

						def ex = func(expr);

						if (ex === expr)
						{
							def e = expr :> LambdaExpression;
							def b = Transform(e.Body,       func);
							def p = Transform(e.Parameters, func);

							if (b !== e.Body || p !== e.Parameters)
								Expression.Lambda(ex.Type, b, p.ToArray())
							else
								expr
						}
						else
							ex

					| ExpressionType.ListInit        =>

						transform ListInitExpression members (
							Transform (e.NewExpression, func) :> NewExpression,
							TransformT(e.Initializers,  p =>
							{
								def args = Transform(p.Arguments, func);
								if (args !== p.Arguments) Expression.ElementInit(p.AddMethod, args) else p
							}))

					| ExpressionType.MemberInit      =>

						def exp = func(expr);
						when (exp !== expr)
							return exp;

						def modify(b : MemberBinding) : MemberBinding
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment    =>

									def ma = b :> MemberAssignment;
									def ex = Transform(ma.Expression, func);
									if (ex !== ma.Expression) Expression.Bind(ma.Member, ex) else ma

								| MemberBindingType.ListBinding   =>

									def ml = b :> MemberListBinding;
									def i  = TransformT(ml.Initializers, p =>
									{
										def args = Transform(p.Arguments, func);
										if (args !== p.Arguments) Expression.ElementInit(p.AddMethod, args) else p;
									});

									if (i !== ml.Initializers) Expression.ListBind(ml.Member, i) else ml

								| MemberBindingType.MemberBinding =>

									def mm = b :> MemberMemberBinding;
									def bs = TransformT(mm.Bindings, modify);
									if (bs !== mm.Bindings) Expression.MemberBind(mm.Member) else mm

								| _ => b
							}
						}

						transform MemberInitExpression members (
							Transform (e.NewExpression, func) :> NewExpression,
							TransformT(e.Bindings, modify));

					/*//////////////////////////
					case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
						{
							var exp = func(expr);
							if (exp != expr)
								return exp;

							var e  = (ChangeTypeExpression)expr;
							var ex = Transform(e.Expression, func);

							if (ex == e.Expression)
								return expr;

							if (ex.Type == e.Type)
								return ex;

							return new ChangeTypeExpression(ex, e.Type);
						}
					*/

					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Goto          | ExpressionType.Index           | ExpressionType.Label           | ExpressionType.Loop
					| ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => throw InvalidOperationException()
				}
		}

		#endregion

		#region Transform2

		static Transform[T](source : ICollection[T], func : Expression -> TransformInfo) : IEnumerable[T]
			where T : Expression
		{
			mutable modified = false;
			def @list = List();

			foreach (item in source)
			{
				def e = Transform(item, func);
				@list.Add(e :> T);
				modified = modified || e !== item
			}

			if (modified) @list else source
		}

		public static Transform(this expr : Expression, func : Func[Expression,TransformInfo]) : Expression
		{
			Transform(expr, func.Invoke)
		}

		public static Transform(this expr : Expression, func : Expression -> TransformInfo) : Expression
		{
			if (expr == null)
				null
			else
				match (expr.NodeType)
				{
					| ExpressionType.Assign        | ExpressionType.Add             | ExpressionType.AddChecked      | ExpressionType.And
					| ExpressionType.AndAlso       | ExpressionType.ArrayIndex      | ExpressionType.Coalesce        | ExpressionType.Divide
					| ExpressionType.Equal         | ExpressionType.ExclusiveOr     | ExpressionType.GreaterThan     | ExpressionType.GreaterThanOrEqual
					| ExpressionType.LeftShift     | ExpressionType.LessThan        | ExpressionType.LessThanOrEqual | ExpressionType.SubtractAssignChecked
					| ExpressionType.Multiply      | ExpressionType.NotEqual        | ExpressionType.MultiplyChecked | ExpressionType.MultiplyAssignChecked
					| ExpressionType.OrElse        | ExpressionType.Power           | ExpressionType.RightShift      | ExpressionType.ExclusiveOrAssign
					| ExpressionType.Or            | ExpressionType.Modulo          | ExpressionType.AddAssign       | ExpressionType.LeftShiftAssign
					| ExpressionType.AndAssign     | ExpressionType.DivideAssign    | ExpressionType.ModuloAssign    | ExpressionType.AddAssignChecked
					| ExpressionType.PowerAssign   | ExpressionType.MultiplyAssign  | ExpressionType.OrAssign        | ExpressionType.RightShiftAssign
					| ExpressionType.Subtract
					| ExpressionType.SubtractAssign
					| ExpressionType.SubtractChecked => transform2 BinaryExpression      members (Left, Transform(e.Conversion, func) :> LambdaExpression, Right)
					| ExpressionType.ArrayLength
					| ExpressionType.Convert       | ExpressionType.ConvertChecked  | ExpressionType.Negate          | ExpressionType.PostIncrementAssign
					| ExpressionType.Not           | ExpressionType.Quote           | ExpressionType.OnesComplement  | ExpressionType.PostDecrementAssign
					| ExpressionType.NegateChecked | ExpressionType.IsFalse         | ExpressionType.IsTrue          | ExpressionType.PreDecrementAssign
					| ExpressionType.Unbox         | ExpressionType.TypeAs          | ExpressionType.Increment       | ExpressionType.PreIncrementAssign
					| ExpressionType.Decrement
					| ExpressionType.UnaryPlus       => transform2 UnaryExpression       members (Operand)
					| ExpressionType.Call            => transform2 MethodCallExpression  members (Object,     Arguments)
					| ExpressionType.Conditional     => transform2 ConditionalExpression members (Test,       IfTrue,  IfFalse)
					| ExpressionType.Invoke          => transform2 InvocationExpression  members (Expression, Arguments)
					| ExpressionType.MemberAccess    => transform2 MemberExpression      members (Expression)
					| ExpressionType.New             => transform2 NewExpression         members (Arguments)
					| ExpressionType.NewArrayBounds  => transform2 NewArrayExpression    members (Expressions)
					| ExpressionType.NewArrayInit    => transform2 NewArrayExpression    members (Expressions)
					| ExpressionType.TypeEqual
					| ExpressionType.TypeIs          => transform2 TypeBinaryExpression  members (Expression)
					| ExpressionType.Block           => transform2 BlockExpression       members (Variables, Expressions)
 					| ExpressionType.Extension
					| ExpressionType.Constant
					| ExpressionType.Parameter       => func(expr).Expression
					| ExpressionType.Lambda          =>

						def ex = func(expr);
						when (ex.Stop || ex.Expression !== expr)
							return ex.Expression;

						def e = expr :> LambdaExpression;
						def b = Transform(e.Body,       func);
						def p = Transform(e.Parameters, func);

						if (b !== e.Body || p !== e.Parameters)
							Expression.Lambda(ex.Expression.Type, b, p.ToArray())
						else
							expr

					| ExpressionType.ListInit        =>

						transform2 ListInitExpression members (
							Transform (e.NewExpression, func) :> NewExpression,
							TransformT(e.Initializers,  p =>
							{
								def args = Transform(p.Arguments, func);
								if (args !== p.Arguments) Expression.ElementInit(p.AddMethod, args) else p
							}))

					| ExpressionType.MemberInit      =>

						def modify(b : MemberBinding) : MemberBinding
						{
							match (b.BindingType)
							{
								| MemberBindingType.Assignment    =>

									def ma = b :> MemberAssignment;
									def ex = Transform(ma.Expression, func);

									if (ex !== ma.Expression) Expression.Bind(ma.Member, ex) else ma

								| MemberBindingType.ListBinding   =>

									def ml = b :> MemberListBinding;
									def i  = TransformT(ml.Initializers, p =>
									{
										def args = Transform(p.Arguments, func);
										if (args !== p.Arguments) Expression.ElementInit(p.AddMethod, args) else p
									});

									if (i !== ml.Initializers) Expression.ListBind(ml.Member, i) else ml

								| MemberBindingType.MemberBinding =>

									def mm = b :> MemberMemberBinding;
									def bs = TransformT(mm.Bindings, modify);

									if (bs !== mm.Bindings) Expression.MemberBind(mm.Member) else mm

								| _ => b
							}
						}

						transform2 MemberInitExpression members (
							Transform (e.NewExpression, func) :> NewExpression,
							TransformT(e.Bindings,      modify));

					/*/////////////////////////
					| (ExpressionType)ChangeTypeExpression.ChangeTypeType =>
						{
							var exp = func(expr);
							if (exp.Stop || exp.Expression != expr)
								return exp.Expression;

							var e  = (ChangeTypeExpression)expr;
							var ex = Transform2(e.Expression, func);

							if (ex == e.Expression)
								return expr;

							if (ex.Type == e.Type)
								return ex;

							return new ChangeTypeExpression(ex, e.Type);
						}
					*/
					| ExpressionType.DebugInfo     | ExpressionType.Dynamic         | ExpressionType.Default         | ExpressionType.RuntimeVariables
					| ExpressionType.Goto          | ExpressionType.Index           | ExpressionType.Label           | ExpressionType.Loop
					| ExpressionType.Switch
					| ExpressionType.Try
					| ExpressionType.Throw           => throw InvalidOperationException()
				}
		}

		#endregion

		#region Helpers

		static public Unwrap(this ex : Expression) : Expression
		{
			| Quote         (op)
			| ConvertExpr   (op) when !op.Type.IsEnum
			| ConvertChecked(op) when !op.Type.IsEnum => op.Unwrap()
			| ex                                      => ex
		}

		static public GetExpressionAccessors(this expression : Expression, pathExpr : Expression) : Dictionary[Expression,Expression]
		{
			def accessors = Dictionary();

			expression.Path(pathExpr, (e,p) =>
			{
				match (e.NodeType)
				{
					| ExpressionType.Call
					| ExpressionType.MemberAccess
					| ExpressionType.New            =>

						when (!accessors.ContainsKey(e))
							accessors.Add(e, p);

					| ExpressionType.Constant       =>

						when (!accessors.ContainsKey(e))
							accessors.Add(e, Expression.Property(p, infoof(ConstantExpression.Value)));

					| ExpressionType.ConvertChecked
					| ExpressionType.Convert        =>

						when (!accessors.ContainsKey(e))
						{
							def ue = e :> UnaryExpression;

							match (ue.Operand.NodeType)
							{
								| ExpressionType.Call
								| ExpressionType.MemberAccess
								| ExpressionType.New
								| ExpressionType.Constant => accessors.Add(e, p);
								| _ => ()
							}
						}

					| _ => ()
				}
			});

			accessors
		}

		static public GetRootObject(this expr : Expression) : Expression
		{
			if (expr == null)
				null
			else
				match (expr)
				{
					| Member(null, _, _)    => expr
					| Call  (null, _, null) => expr
					| Call  (null, _, args) as e when args.Count > 0 && e.IsQueryable() => GetRootObject(args[0])
					| Call  (null, _, _   ) => expr
					| Call  (obj,  _, _   ) => GetRootObject(obj)
					| Member(ex,   _, _)    => GetRootObject(ex.Unwrap())
					| _                     => expr
				}
		}

		static public GetMembers(this expr : Expression) : List[Expression]
		{
			if (expr == null)
				List()
			else
				(match (expr)
				{
					| Member(null, _, _)    => List()
					| Call  (null, _, null) => List()
					| Call  (null, _, args) as e when args.Count > 0 && e.IsQueryable() => GetMembers(args[0])
					| Call  (null, _, _   ) => List()
					| Call  (obj,  _, _   ) => GetMembers(obj)
					| Member(expr, _, _)    => GetMembers(expr.Unwrap())
					| _                     => List()
				}) <- [ expr ]
		}

		static public IsQueryable(this method : MethodCallExpression) : bool
		{
			def type = method.Method.DeclaringType;
			type == typeof(Queryable) || type == typeof(Enumerable) ////////////////////|| type == typeof(LinqExtensions);
		}

		static public IsQueryable(this method : MethodCallExpression, name : string) : bool
		{
			method.Method.Name == name && method.IsQueryable();
		}

		static public IsQueryable(this method : MethodCallExpression, params names : array[string]) : bool
		{
			when (method.IsQueryable())
				foreach (name in names)
					when (method.Method.Name == name)
						return true;
			false
		}

		static public GetLevelExpression(this expression : Expression, level : int) : Expression
		{
			def findLevel(ex : Expression, current : int) : Expression * int
			{
				def next(expr)
				{
					def (e,cur) = findLevel(expr, current);
					if (level == cur) (e, cur) else (ex, cur + 1)
				}

				match (ex)
				{
					| Member(null, _, _)    => (ex, current)
					| Call  (null, _, null) => (ex, current)
					| Call  (null, _, args) as c when args.Count > 0 && c.IsQueryable() => next(args[0])
					| Call  (null, _, _)    => (ex, current)
					| Call  (obj,  _, _)    => next(obj)
					| Member(e,    _, _)    => next(e.Unwrap())
					| _                     => (ex, current)
				}
			}

			def (expr,current) = findLevel(expression, 0);

			if (expr == null || current != level)
				throw InvalidOperationException();
			else
				expr
		}

		#endregion
	}
}
