using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;

using Nemerle;
using Nemerle.Imperative;

namespace LinqToDB_Temp.Extensions
{
	using MacroInternal;

	public module LinqExpressionExtensions
	{
		#region IsConstant

		public IsConstantable(this type : Type) : bool
		{
			match (Type.GetTypeCode(type.ToUnderlying()))
			{
				| Int16
				| Int32
				| Int64
				| UInt16
				| UInt32
				| UInt64
				| SByte
				| Byte
				| Decimal
				| Double
				| Single
				| Boolean
				| String
				| Char    => true
				| _       => false
			}
		}

		#endregion

		#region EqualsTo

		public EqualsTo(this expr1 : Expression, expr2 : Expression, queryableAccessorDic : Dictionary[Expression,Func[Expression,IQueryable]]) : bool
		{
			if (ReferenceEquals(expr1, expr2))
				true
			else if (expr1 == null || expr2 == null || expr1.NodeType != expr2.NodeType || expr1.Type != expr2.Type)
				false
			else match (expr1.NodeType)
			{
				| ExpressionType.Add
				| ExpressionType.AddChecked
				| ExpressionType.And
				| ExpressionType.AndAlso
				| ExpressionType.ArrayIndex
#if FW4 || SILVERLIGHT
				| ExpressionType.Assign
#endif
				| ExpressionType.Coalesce
				| ExpressionType.Divide
				| ExpressionType.Equal
				| ExpressionType.ExclusiveOr
				| ExpressionType.GreaterThan
				| ExpressionType.GreaterThanOrEqual
				| ExpressionType.LeftShift
				| ExpressionType.LessThan
				| ExpressionType.LessThanOrEqual
				| ExpressionType.Modulo
				| ExpressionType.Multiply
				| ExpressionType.MultiplyChecked
				| ExpressionType.NotEqual
				| ExpressionType.Or
				| ExpressionType.OrElse
				| ExpressionType.Power
				| ExpressionType.RightShift
				| ExpressionType.Subtract
				| ExpressionType.SubtractChecked =>

					def e1 = expr1 :> BinaryExpression;
					def e2 = expr2 :> BinaryExpression;

					e1.Method == e2.Method &&
					e1.Conversion.EqualsTo(e2.Conversion, queryableAccessorDic) &&
					e1.Left.      EqualsTo(e2.Left,       queryableAccessorDic) &&
					e1.Right.     EqualsTo(e2.Right,      queryableAccessorDic)

				| ExpressionType.ArrayLength
				| ExpressionType.Convert
				| ExpressionType.ConvertChecked
				| ExpressionType.Negate
				| ExpressionType.NegateChecked
				| ExpressionType.Not
				| ExpressionType.Quote
				| ExpressionType.TypeAs
				| ExpressionType.UnaryPlus =>

					def e1 = expr1 :> UnaryExpression;
					def e2 = expr2 :> UnaryExpression;

					e1.Method == e2.Method && e1.Operand.EqualsTo(e2.Operand, queryableAccessorDic)

				| ExpressionType.Call =>

					def e1 = expr1 :> MethodCallExpression;
					def e2 = expr2 :> MethodCallExpression;

					when (e1.Arguments.Count != e2.Arguments.Count || e1.Method != e2.Method)
						return false;

					when (queryableAccessorDic.Count > 0)
					{
						mutable func;

						when (queryableAccessorDic.TryGetValue(expr1, out func))
							return func(expr1).Expression.EqualsTo(func(expr2).Expression, queryableAccessorDic);
					}

					when (!e1.Object.EqualsTo(e2.Object, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!e1.Arguments[i].EqualsTo(e2.Arguments[i], queryableAccessorDic))
							return false;

					true

				| ExpressionType.Conditional =>

					def e1 = expr1 :> ConditionalExpression;
					def e2 = expr2 :> ConditionalExpression;

					e1.Test.   EqualsTo(e2.Test,    queryableAccessorDic) &&
					e1.IfTrue. EqualsTo(e2.IfTrue,  queryableAccessorDic) &&
					e1.IfFalse.EqualsTo(e2.IfFalse, queryableAccessorDic);

				| ExpressionType.Constant =>

					def e1 = expr1 :> ConstantExpression;
					def e2 = expr2 :> ConstantExpression;

					e1.Type == e2.Type && (e1.Value == null && e2.Value == null || !e1.Type.IsConstantable() || Equals(e1.Value, e2.Value))

				| ExpressionType.Invoke =>

					def e1 = expr1 :> InvocationExpression;
					def e2 = expr2 :> InvocationExpression;

					when (e1.Arguments.Count != e2.Arguments.Count || !e1.Expression.EqualsTo(e2.Expression, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!e1.Arguments[i].EqualsTo(e2.Arguments[i], queryableAccessorDic))
							return false;

					true;

				| ExpressionType.Lambda =>

					def e1 = expr1 :> LambdaExpression;
					def e2 = expr2 :> LambdaExpression;

					when (e1.Parameters.Count != e2.Parameters.Count || !e1.Body.EqualsTo(e2.Body, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Parameters.Count; i++)
						when (!e1.Parameters[i].EqualsTo(e2.Parameters[i], queryableAccessorDic))
							return false;

					true;

				| ExpressionType.ListInit =>

					def e1 = expr1 :> ListInitExpression;
					def e2 = expr2 :> ListInitExpression;

					when (e1.Initializers.Count != e2.Initializers.Count || !e1.NewExpression.EqualsTo(e2.NewExpression, queryableAccessorDic))
						return false;

					for (mutable i = 0; i < e1.Initializers.Count; i++)
					{
						def i1 = e1.Initializers[i];
						def i2 = e2.Initializers[i];

						when (i1.Arguments.Count != i2.Arguments.Count || i1.AddMethod != i2.AddMethod)
							return false;

						for (mutable j = 0; j < i1.Arguments.Count; j++)
							when (!i1.Arguments[j].EqualsTo(i2.Arguments[j], queryableAccessorDic))
								return false;
					}

					true;

				| ExpressionType.MemberAccess =>

					def e1 = expr1 :> MemberExpression;
					def e2 = expr2 :> MemberExpression;

					if (e1.Member == e2.Member)
					{
						when (ReferenceEquals(e1.Expression, e2.Expression))
						{
							when (queryableAccessorDic.Count > 0)
							{
								mutable func;

								when (queryableAccessorDic.TryGetValue(expr1, out func))
									return func(expr1).Expression.EqualsTo(func(expr2).Expression, queryableAccessorDic);
							}
						}

						e1.Expression.EqualsTo(e2.Expression, queryableAccessorDic);
					}
					else
						false

				| ExpressionType.MemberInit =>

					def e1 = expr1 :> MemberInitExpression;
					def e2 = expr2 :> MemberInitExpression;

					when (e1.Bindings.Count != e2.Bindings.Count || !e1.NewExpression.EqualsTo(e2.NewExpression, queryableAccessorDic))
						return false;

					def compareBindings (b1 : MemberBinding, b2 : MemberBinding) : bool
					{
						when (ReferenceEquals(b1, b2))
							return true;

						when (b1 == null || b2 == null || b1.BindingType != b2.BindingType || b1.Member != b2.Member)
							return false;

						match (b1.BindingType)
						{
							| MemberBindingType.Assignment =>
								(b1 :> MemberAssignment).Expression.EqualsTo((b2 :> MemberAssignment).Expression, queryableAccessorDic)

							| MemberBindingType.ListBinding => 
								def ml1 = b1 :> MemberListBinding;
								def ml2 = b2 :> MemberListBinding;

								when (ml1.Initializers.Count != ml2.Initializers.Count)
									return false;

								for (mutable i = 0; i < ml1.Initializers.Count; i++)
								{
									def ei1 = ml1.Initializers[i];
									def ei2 = ml2.Initializers[i];

									when (ei1.AddMethod != ei2.AddMethod || ei1.Arguments.Count != ei2.Arguments.Count)
										return false;

									for (mutable j = 0; j < ei1.Arguments.Count; j++)
										when (!ei1.Arguments[j].EqualsTo(ei2.Arguments[j], queryableAccessorDic))
											return false;
								}

								true;

							| MemberBindingType.MemberBinding =>
								def mm1 = b1 :> MemberMemberBinding;
								def mm2 = b2 :> MemberMemberBinding;

								when (mm1.Bindings.Count != mm2.Bindings.Count)
									return false;

								for (mutable i = 0; i < mm1.Bindings.Count; i++)
									when (!compareBindings(mm1.Bindings[i], mm2.Bindings[i]))
										return false;

								true;
						}
					}

					for (mutable i = 0; i < e1.Bindings.Count; i++)
					{
						def b1 = e1.Bindings[i];
						def b2 = e2.Bindings[i];

						when (!compareBindings(b1, b2))
							return false;
					}

					true

				| ExpressionType.New =>

					def e1 = expr1 :> NewExpression;
					def e2 = expr2 :> NewExpression;

					when (e1.Arguments.Count != e2.Arguments.Count)
						return false;

					when (e1.Members == null && e2.Members != null)
						return false;

					when (e1.Members != null && e2.Members == null)
						return false;

					when (e1.Constructor != e2.Constructor)
						return false;

					when (e1.Members != null)
					{
						when (e1.Members.Count != e2.Members.Count)
							return false;

						for (mutable i = 0; i < e1.Members.Count; i++)
							when (e1.Members[i] != e2.Members[i])
								return false;
					}

					for (mutable i = 0; i < e1.Arguments.Count; i++)
						when (!e1.Arguments[i].EqualsTo(e2.Arguments[i], queryableAccessorDic))
							return false;

					true;

				| ExpressionType.NewArrayBounds
				| ExpressionType.NewArrayInit =>

					def e1 = expr1 :> NewArrayExpression;
					def e2 = expr2 :> NewArrayExpression;

					when (e1.Expressions.Count != e2.Expressions.Count)
						return false;

					for (mutable i = 0; i < e1.Expressions.Count; i++)
						when (!e1.Expressions[i].EqualsTo(e2.Expressions[i], queryableAccessorDic))
							return false;

					true;

				| ExpressionType.Parameter =>

					def e1 = expr1 :> ParameterExpression;
					def e2 = expr2 :> ParameterExpression;
					e1.Name == e2.Name;

				| ExpressionType.TypeIs =>

					def e1 = expr1 :> TypeBinaryExpression;
					def e2 = expr2 :> TypeBinaryExpression;
					e1.TypeOperand == e2.TypeOperand && e1.Expression.EqualsTo(e2.Expression, queryableAccessorDic);

#if FW4 || SILVERLIGHT

				| ExpressionType.Block =>

					def e1 = expr1 :> BlockExpression;
					def e2 = expr2 :> BlockExpression;

					for (mutable i = 0; i < e1.Expressions.Count; i++)
						when (!e1.Expressions[i].EqualsTo(e2.Expressions[i], queryableAccessorDic))
							return false;

					for (mutable i = 0; i < e1.Variables.Count; i++)
						when (!e1.Variables[i].EqualsTo(e2.Variables[i], queryableAccessorDic))
							return false;

					true;

#endif

				| _ => throw InvalidOperationException()
			}
		}

		#endregion

		#region Path

		ConvertTo(expr : Expression, type : Type) : Expression
		{
			Expression.Convert(expr, type);
		}

		Path[T](source : IEnumerable[T], path : Expression, property : MethodInfo, func : T * Expression -> void) : void
			where T : class
		{
			def prop = Expression.Property(path, property);
			mutable i = 0;
			foreach (item in source)
				func(item, Expression.Call(prop, infoof(ReadOnlyCollection[T].Item), array[ Expression.Constant({ i++; i }) ]));
		}

		/*
		Path[T](source : IEnumerable[T], path : Expression, property : MethodInfo, func : Expression * Expression -> void) : void
			where T : Expression
		{
			def prop = Expression.Property(path, property);
			mutable i = 0;
			foreach (item in source)
				Path(item, Expression.Call(prop, infoof(ReadOnlyCollection[T].Item), array[ Expression.Constant({ i++; i }) ]), func);
		}
		*/

		Path(expr : Expression, path : Expression, property : MethodInfo, func : Expression * Expression -> void) : void
		{
			Path(expr, Expression.Property(path, property), func);
		}

		public Path(this expr : Expression, mutable path : Expression, func : Expression * Expression -> void) : void
		{
			when (expr == null)
				return;

			match (expr.NodeType)
			{
				| ExpressionType.Add
				| ExpressionType.AddChecked
				| ExpressionType.And
				| ExpressionType.AndAlso
				| ExpressionType.ArrayIndex
#if FW4 || SILVERLIGHT
				| ExpressionType.Assign
#endif
				| ExpressionType.Coalesce
				| ExpressionType.Divide
				| ExpressionType.Equal
				| ExpressionType.ExclusiveOr
				| ExpressionType.GreaterThan
				| ExpressionType.GreaterThanOrEqual
				| ExpressionType.LeftShift
				| ExpressionType.LessThan
				| ExpressionType.LessThanOrEqual
				| ExpressionType.Modulo
				| ExpressionType.Multiply
				| ExpressionType.MultiplyChecked
				| ExpressionType.NotEqual
				| ExpressionType.Or
				| ExpressionType.OrElse
				| ExpressionType.Power
				| ExpressionType.RightShift
				| ExpressionType.Subtract
				| ExpressionType.SubtractChecked =>

					path  = ConvertTo(path, typeof(BinaryExpression));
					def e = expr :> BinaryExpression;

					Path(e.Conversion, path, infoof(BinaryExpression.Conversion), func);
					Path(e.Left,       path, infoof(BinaryExpression.Left),       func);
					Path(e.Right,      path, infoof(BinaryExpression.Right),      func);

				| ExpressionType.ArrayLength
				| ExpressionType.Convert
				| ExpressionType.ConvertChecked
				| ExpressionType.Negate
				| ExpressionType.NegateChecked
				| ExpressionType.Not
				| ExpressionType.Quote
				| ExpressionType.TypeAs
				| ExpressionType.UnaryPlus =>

					path = ConvertTo(path, typeof(UnaryExpression));
					Path((expr :> UnaryExpression).Operand, path, infoof(UnaryExpression.Operand), func);

				| ExpressionType.Call =>

					path  = ConvertTo(path, typeof(MethodCallExpression));
					def e = expr :> MethodCallExpression;

					Path(e.Object,    path, infoof(MethodCallExpression.Object),    func);
					Path(e.Arguments, path, infoof(MethodCallExpression.Arguments), func);

				| ExpressionType.Conditional =>

					path  = ConvertTo(path, typeof(ConditionalExpression));
					def e = expr :> ConditionalExpression;

					Path(e.Test,    path, infoof(ConditionalExpression.Test),    func);
					Path(e.IfTrue,  path, infoof(ConditionalExpression.IfTrue),  func);
					Path(e.IfFalse, path, infoof(ConditionalExpression.IfFalse), func);

				| ExpressionType.Invoke =>

					path  = ConvertTo(path, typeof(InvocationExpression));
					def e = expr :> InvocationExpression;

					Path(e.Expression, path, infoof(InvocationExpression.Expression), func);
					Path(e.Arguments,  path, infoof(InvocationExpression.Arguments),  func);

				| ExpressionType.Lambda =>

					path  = ConvertTo(path, typeof(LambdaExpression));
					def e = expr :> LambdaExpression;

					Path(e.Body,       path, infoof(LambdaExpression.Body),       func);
					Path(e.Parameters, path, infoof(LambdaExpression.Parameters), func);

				| ExpressionType.ListInit =>

					path  = ConvertTo(path, typeof(ListInitExpression));
					def e = expr :> ListInitExpression;

					Path(e.NewExpression, path, infoof(ListInitExpression.NewExpression), func);
					Path(e.Initializers,  path, infoof(ListInitExpression.Initializers), (ex,p) => Path(ex.Arguments, p, infoof(ElementInit.Arguments), func));

				| ExpressionType.MemberAccess =>

					path = ConvertTo(path, typeof(MemberExpression));
					Path((expr :> MemberExpression).Expression, path, infoof(MemberExpression.Expression), func);

				| ExpressionType.MemberInit =>

					def modify(b : MemberBinding, pinf : Expression)
					{
						match (b.BindingType)
						{
							| MemberBindingType.Assignment =>
								Path(
									(b :> MemberAssignment).Expression,
									ConvertTo(pinf, typeof(MemberAssignment)),
									infoof(MemberAssignment.Expression),
									func);

							| MemberBindingType.ListBinding =>
								Path(
									(b :> MemberListBinding).Initializers,
									ConvertTo(pinf, typeof(MemberListBinding)),
									infoof(MemberListBinding.Initializers),
									(p,psi) => Path(p.Arguments, psi, infoof(ElementInit.Arguments), func));

							| MemberBindingType.MemberBinding =>
								Path(
									(b :> MemberMemberBinding).Bindings,
									ConvertTo(pinf, typeof(MemberMemberBinding)),
									infoof(MemberMemberBinding.Bindings),
									modify);
						}
					}

					path  = ConvertTo(path, typeof(MemberInitExpression));
					def e = expr :> MemberInitExpression;

					Path(e.NewExpression, path, infoof(MemberInitExpression.NewExpression), func);
					Path(e.Bindings,      path, infoof(MemberInitExpression.Bindings),      modify);

				| ExpressionType.New =>

					path = ConvertTo(path, typeof(NewExpression));
					Path((expr :> NewExpression).Arguments, path, infoof(NewExpression.Arguments), func);

				| ExpressionType.NewArrayBounds =>

					path = ConvertTo(path, typeof(NewArrayExpression));
					Path((expr :> NewArrayExpression).Expressions, path, infoof(NewArrayExpression.Expressions), func);

				| ExpressionType.NewArrayInit =>

					path = ConvertTo(path, typeof(NewArrayExpression));
					Path((expr :> NewArrayExpression).Expressions, path, infoof(NewArrayExpression.Expressions), func);

				| ExpressionType.TypeIs =>

					path = ConvertTo(path, typeof(TypeBinaryExpression));
					Path((expr :> TypeBinaryExpression).Expression, path, infoof(TypeBinaryExpression.Expression), func);

#if FW4 || SILVERLIGHT

				| ExpressionType.Block =>

					path  = ConvertTo(path, typeof(BlockExpression));
					def e = expr :> BlockExpression;

					Path(e.Expressions, path, infoof(Block.Expressions), func);
					Path(e.Variables,   path, infoof(Block.Variables),   func); // ?

#endif

				| ExpressionType.Constant => path = ConvertTo(path, typeof(ConstantExpression));
				| ExpressionType.Parameter=> path = ConvertTo(path, typeof(ParameterExpression));
				| _ => throw InvalidOperationException()
			}

			func(expr, path);
		}

		#endregion

		#region Visit

		static Visit[T](source : IEnumerable[T], func : T -> void) : void
		{
			foreach (item in source)
				func(item);
		}

		/*
		static Visit[T](source : IEnumerable[T], func : Expression -> void) : void
			where T : Expression
		{
			foreach (item in source)
				Visit(item, func);
		}
		*/

		public static Visit(this expr : Expression, func : Expression -> void) : void
		{
			when (expr == null)
				return;

			match (expr.NodeType)
			{
				| ExpressionType.Add
				| ExpressionType.AddChecked
				| ExpressionType.And
				| ExpressionType.AndAlso
				| ExpressionType.ArrayIndex
#if FW4 || SILVERLIGHT
				| ExpressionType.Assign
#endif
				| ExpressionType.Coalesce
				| ExpressionType.Divide
				| ExpressionType.Equal
				| ExpressionType.ExclusiveOr
				| ExpressionType.GreaterThan
				| ExpressionType.GreaterThanOrEqual
				| ExpressionType.LeftShift
				| ExpressionType.LessThan
				| ExpressionType.LessThanOrEqual
				| ExpressionType.Modulo
				| ExpressionType.Multiply
				| ExpressionType.MultiplyChecked
				| ExpressionType.NotEqual
				| ExpressionType.Or
				| ExpressionType.OrElse
				| ExpressionType.Power
				| ExpressionType.RightShift
				| ExpressionType.Subtract
				| ExpressionType.SubtractChecked =>

					def e = expr :> BinaryExpression;

					Visit(e.Conversion, func);
					Visit(e.Left,       func);
					Visit(e.Right,      func);

				| ExpressionType.ArrayLength
				| ExpressionType.Convert
				| ExpressionType.ConvertChecked
				| ExpressionType.Negate
				| ExpressionType.NegateChecked
				| ExpressionType.Not
				| ExpressionType.Quote
				| ExpressionType.TypeAs
				| ExpressionType.UnaryPlus =>

					Visit((expr :> UnaryExpression).Operand, func);

				| ExpressionType.Call =>

					def e = expr :> MethodCallExpression;

					Visit(e.Object,    func);
					Visit(e.Arguments, func);

				| ExpressionType.Conditional =>

					def e = expr :> ConditionalExpression;

					Visit(e.Test,    func);
					Visit(e.IfTrue,  func);
					Visit(e.IfFalse, func);

				| ExpressionType.Invoke =>

					def e = expr :> InvocationExpression;

					Visit(e.Expression, func);
					Visit(e.Arguments,  func);

				| ExpressionType.Lambda =>

					def e = expr :> LambdaExpression;

					Visit(e.Body,       func);
					Visit(e.Parameters, func);

				| ExpressionType.ListInit =>

					def e = expr :> ListInitExpression;

					Visit(e.NewExpression, func);
					Visit(e.Initializers,  ex => Visit(ex.Arguments, func));

				| ExpressionType.MemberAccess => Visit((expr :> MemberExpression).Expression, func);

				| ExpressionType.MemberInit =>

					def modify(b : MemberBinding)
					{
						match (b.BindingType)
						{
							| MemberBindingType.Assignment    => Visit((b :> MemberAssignment). Expression,   func);
							| MemberBindingType.ListBinding   => Visit((b :> MemberListBinding).Initializers, p => Visit(p.Arguments, func));
							| MemberBindingType.MemberBinding => Visit((b :> MemberMemberBinding).Bindings,   modify);
						}
					};

					def e = expr :> MemberInitExpression;

					Visit(e.NewExpression, func);
					Visit(e.Bindings,      modify);

				| ExpressionType.New            => Visit((expr :> NewExpression       ).Arguments,   func)
				| ExpressionType.NewArrayBounds => Visit((expr :> NewArrayExpression  ).Expressions, func)
				| ExpressionType.NewArrayInit   => Visit((expr :> NewArrayExpression  ).Expressions, func)
				| ExpressionType.TypeIs         => Visit((expr :> TypeBinaryExpression).Expression,  func)

#if FW4 || SILVERLIGHT

				| ExpressionType.Block =>

					def e = (BlockExpression)expr;

					Visit(e.Expressions, func);
					Visit(e.Variables,   func);

#endif

				// !!!!!!!!!!!!!!!!| x when x == (ChangeTypeExpression.ChangeTypeType : ExpressionType) =>
				//	Visit(((ChangeTypeExpression)expr).Expression,  func); break;
				| _ => throw InvalidOperationException()
			}

			func(expr);
		}

		static Visit[T](source : IEnumerable[T], func : T -> bool) : void
		{
			foreach (item in source)
				_ = func(item);
		}

		/*
		static Visit[T](source : IEnumerable[T], func : Expression -> bool) : void
			where T : Expression
		{
			foreach (item in source)
				Visit(item, func);
		}
		*/

		public static Visit(this expr : Expression, func : Expression -> bool) : void
		{
			when (expr == null || !func(expr))
				return;

			match (expr.NodeType)
			{
				| ExpressionType.Add
				| ExpressionType.AddChecked
				| ExpressionType.And
				| ExpressionType.AndAlso
				| ExpressionType.ArrayIndex
#if FW4 || SILVERLIGHT
				| ExpressionType.Assign
#endif
				| ExpressionType.Coalesce
				| ExpressionType.Divide
				| ExpressionType.Equal
				| ExpressionType.ExclusiveOr
				| ExpressionType.GreaterThan
				| ExpressionType.GreaterThanOrEqual
				| ExpressionType.LeftShift
				| ExpressionType.LessThan
				| ExpressionType.LessThanOrEqual
				| ExpressionType.Modulo
				| ExpressionType.Multiply
				| ExpressionType.MultiplyChecked
				| ExpressionType.NotEqual
				| ExpressionType.Or
				| ExpressionType.OrElse
				| ExpressionType.Power
				| ExpressionType.RightShift
				| ExpressionType.Subtract
				| ExpressionType.SubtractChecked =>

					def e = expr :> BinaryExpression;

					Visit(e.Conversion, func);
					Visit(e.Left,       func);
					Visit(e.Right,      func);

				| ExpressionType.ArrayLength
				| ExpressionType.Convert
				| ExpressionType.ConvertChecked
				| ExpressionType.Negate
				| ExpressionType.NegateChecked
				| ExpressionType.Not
				| ExpressionType.Quote
				| ExpressionType.TypeAs
				| ExpressionType.UnaryPlus =>
					Visit((expr :> UnaryExpression).Operand, func);

				| ExpressionType.Call =>

					def e = expr :> MethodCallExpression;

					Visit(e.Object,    func);
					Visit(e.Arguments, func);

				| ExpressionType.Conditional =>

					def e = expr :> ConditionalExpression;

					Visit(e.Test,    func);
					Visit(e.IfTrue,  func);
					Visit(e.IfFalse, func);

				| ExpressionType.Invoke =>

					def e = expr :> InvocationExpression;

					Visit(e.Expression, func);
					Visit(e.Arguments,  func);

				| ExpressionType.Lambda =>

					def e = expr :> LambdaExpression;

					Visit(e.Body,       func);
					Visit(e.Parameters, func);

				| ExpressionType.ListInit =>

					def e = expr :> ListInitExpression;

					Visit(e.NewExpression, func);
					Visit(e.Initializers,  ex => Visit(ex.Arguments, func));

				| ExpressionType.MemberAccess => Visit((expr :> MemberExpression).Expression, func);

				| ExpressionType.MemberInit =>

					def modify(b) : bool
					{
						match (b.BindingType)
						{
							| MemberBindingType.Assignment    => Visit((b :> MemberAssignment)   .Expression,   func);
							| MemberBindingType.ListBinding   => Visit((b :> MemberListBinding)  .Initializers, p => Visit(p.Arguments, func));
							| MemberBindingType.MemberBinding => Visit((b :> MemberMemberBinding).Bindings,     modify);
						}

						true
					}

					def e = expr :> MemberInitExpression;

					Visit(e.NewExpression, func);
					Visit(e.Bindings,      modify);

				| ExpressionType.New            => Visit((expr :> NewExpression)       .Arguments,   func);
				| ExpressionType.NewArrayBounds => Visit((expr :> NewArrayExpression)  .Expressions, func);
				| ExpressionType.NewArrayInit   => Visit((expr :> NewArrayExpression)  .Expressions, func);
				| ExpressionType.TypeIs         => Visit((expr :> TypeBinaryExpression).Expression,  func);

#if FW4 || SILVERLIGHT

				| ExpressionType.Block =>

					var e = expr :> BlockExpression;

					Visit(e.Expressions, func);
					Visit(e.Variables,   func);

#endif

				//case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
				//	Visit(((ChangeTypeExpression)expr).Expression,  func);
				//	break;
				| _ => throw InvalidOperationException()
			}
		}

		#endregion

/*
		#region Find

		static Expression Find<T>(IEnumerable<T> source, Func<T,Expression> func)
		{
			foreach (var item in source)
			{
				var ex = func(item);
				if (ex != null)
					return ex;
			}

			return null;
		}

		static Expression Find<T>(IEnumerable<T> source, Func<Expression,bool> func)
			where T : Expression
		{
			foreach (var item in source)
			{
				var f = Find(item, func);
				if (f != null)
					return f;
			}

			return null;
		}

		public static Expression Find(this Expression expr, Func<Expression,bool> func)
		{
			if (expr == null || func(expr))
				return expr;

			switch (expr.NodeType)
			{
				case ExpressionType.Add:
				case ExpressionType.AddChecked:
				case ExpressionType.And:
				case ExpressionType.AndAlso:
				case ExpressionType.ArrayIndex:
#if FW4 || SILVERLIGHT
				case ExpressionType.Assign:
#endif
				case ExpressionType.Coalesce:
				case ExpressionType.Divide:
				case ExpressionType.Equal:
				case ExpressionType.ExclusiveOr:
				case ExpressionType.GreaterThan:
				case ExpressionType.GreaterThanOrEqual:
				case ExpressionType.LeftShift:
				case ExpressionType.LessThan:
				case ExpressionType.LessThanOrEqual:
				case ExpressionType.Modulo:
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyChecked:
				case ExpressionType.NotEqual:
				case ExpressionType.Or:
				case ExpressionType.OrElse:
				case ExpressionType.Power:
				case ExpressionType.RightShift:
				case ExpressionType.Subtract:
				case ExpressionType.SubtractChecked:
					{
						var e = (BinaryExpression)expr;

						return
							Find(e.Conversion, func) ??
							Find(e.Left,       func) ??
							Find(e.Right,      func);
					}

				case ExpressionType.ArrayLength:
				case ExpressionType.Convert:
				case ExpressionType.ConvertChecked:
				case ExpressionType.Negate:
				case ExpressionType.NegateChecked:
				case ExpressionType.Not:
				case ExpressionType.Quote:
				case ExpressionType.TypeAs:
				case ExpressionType.UnaryPlus:
					return Find(((UnaryExpression)expr).Operand, func);

				case ExpressionType.Call:
					{
						var e = (MethodCallExpression)expr;

						return
							Find(e.Object,    func) ??
							Find(e.Arguments, func);
					}

				case ExpressionType.Conditional:
					{
						var e = (ConditionalExpression)expr;

						return
							Find(e.Test,    func) ??
							Find(e.IfTrue,  func) ??
							Find(e.IfFalse, func);
					}

				case ExpressionType.Invoke:
					{
						var e = (InvocationExpression)expr;

						return
							Find(e.Expression, func) ??
							Find(e.Arguments,  func);
					}

				case ExpressionType.Lambda:
					{
						var e = (LambdaExpression)expr;

						return
							Find(e.Body,       func) ??
							Find(e.Parameters, func);
					}

				case ExpressionType.ListInit:
					{
						var e = (ListInitExpression)expr;

						return
							Find(e.NewExpression, func) ??
							Find(e.Initializers,  ex => Find(ex.Arguments, func));
					}

				case ExpressionType.MemberAccess:
					return Find(((MemberExpression)expr).Expression, func);

				case ExpressionType.MemberInit:
					{
						Func<MemberBinding,Expression> modify = null; modify = b =>
						{
							switch (b.BindingType)
							{
								case MemberBindingType.Assignment    : return Find(((MemberAssignment)b).   Expression,   func);
								case MemberBindingType.ListBinding   : return Find(((MemberListBinding)b).  Initializers, p => Find(p.Arguments, func));
								case MemberBindingType.MemberBinding : return Find(((MemberMemberBinding)b).Bindings,     modify);
							}

							return null;
						};

						var e = (MemberInitExpression)expr;

						return
							Find(e.NewExpression, func) ??
							Find(e.Bindings,      modify);
					}

				case ExpressionType.New            : return Find(((NewExpression)       expr).Arguments,   func);
				case ExpressionType.NewArrayBounds : return Find(((NewArrayExpression)  expr).Expressions, func);
				case ExpressionType.NewArrayInit   : return Find(((NewArrayExpression)  expr).Expressions, func);
				case ExpressionType.TypeIs         : return Find(((TypeBinaryExpression)expr).Expression,  func);

#if FW4 || SILVERLIGHT

				case ExpressionType.Block:
					{
						var e = (BlockExpression)expr;

						return
							Find(e.Expressions, func) ??
							Find(e.Variables,   func);
					}

#endif

				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
					return Find(((ChangeTypeExpression)expr).Expression, func);
			}

			return null;
		}

		#endregion

		#region Transform

		static IEnumerable<T> Transform<T>(ICollection<T> source, Func<T,T> func)
			where T : class
		{
			var modified = false;
			var list     = new List<T>();

			foreach (var item in source)
			{
				var e = func(item);
				list.Add(e);
				modified = modified || e != item;
			}

			return modified ? list : source;
		}

		static IEnumerable<T> Transform<T>(ICollection<T> source, Func<Expression,Expression> func)
			where T : Expression
		{
			var modified = false;
			var list     = new List<T>();

			foreach (var item in source)
			{
				var e = Transform(item, func);
				list.Add((T)e);
				modified = modified || e != item;
			}

			return modified? list: source;
		}

		public static Expression Transform(this Expression expr, Func<Expression,Expression> func)
		{
			if (expr == null)
				return null;

			switch (expr.NodeType)
			{
				case ExpressionType.Add:
				case ExpressionType.AddChecked:
				case ExpressionType.And:
				case ExpressionType.AndAlso:
				case ExpressionType.ArrayIndex:
#if FW4 || SILVERLIGHT
				case ExpressionType.Assign:
#endif
				case ExpressionType.Coalesce:
				case ExpressionType.Divide:
				case ExpressionType.Equal:
				case ExpressionType.ExclusiveOr:
				case ExpressionType.GreaterThan:
				case ExpressionType.GreaterThanOrEqual:
				case ExpressionType.LeftShift:
				case ExpressionType.LessThan:
				case ExpressionType.LessThanOrEqual:
				case ExpressionType.Modulo:
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyChecked:
				case ExpressionType.NotEqual:
				case ExpressionType.Or:
				case ExpressionType.OrElse:
				case ExpressionType.Power:
				case ExpressionType.RightShift:
				case ExpressionType.Subtract:
				case ExpressionType.SubtractChecked:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (BinaryExpression)expr;
						var c = Transform(e.Conversion, func);
						var l = Transform(e.Left,       func);
						var r = Transform(e.Right,      func);

						return c != e.Conversion || l != e.Left || r != e.Right ?
							Expression.MakeBinary(expr.NodeType, l, r, e.IsLiftedToNull, e.Method, (LambdaExpression)c):
							expr;
					}

				case ExpressionType.ArrayLength:
				case ExpressionType.Convert:
				case ExpressionType.ConvertChecked:
				case ExpressionType.Negate:
				case ExpressionType.NegateChecked:
				case ExpressionType.Not:
				case ExpressionType.Quote:
				case ExpressionType.TypeAs:
				case ExpressionType.UnaryPlus:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (UnaryExpression)expr;
						var o = Transform(e.Operand, func);

						return o != e.Operand ?
							Expression.MakeUnary(expr.NodeType, o, e.Type, e.Method) :
							expr;
					}

				case ExpressionType.Call:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (MethodCallExpression)expr;
						var o = Transform(e.Object,    func);
						var a = Transform(e.Arguments, func);

						return o != e.Object || a != e.Arguments ? 
							Expression.Call(o, e.Method, a) : 
							expr;
					}

				case ExpressionType.Conditional:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (ConditionalExpression)expr;
						var s = Transform(e.Test,    func);
						var t = Transform(e.IfTrue,  func);
						var f = Transform(e.IfFalse, func);

						return s != e.Test || t != e.IfTrue || f != e.IfFalse ?
							Expression.Condition(s, t, f) :
							expr;
					}

				case ExpressionType.Invoke:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (InvocationExpression)expr;
						var ex = Transform(e.Expression, func);
						var a  = Transform(e.Arguments,  func);

						return ex != e.Expression || a != e.Arguments ? Expression.Invoke(ex, a) : expr;
					}

				case ExpressionType.Lambda:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (LambdaExpression)expr;
						var b = Transform(e.Body,       func);
						var p = Transform(e.Parameters, func);

						return b != e.Body || p != e.Parameters ? Expression.Lambda(ex.Type, b, p.ToArray()) : expr;
					}

				case ExpressionType.ListInit:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (ListInitExpression)expr;
						var n = Transform(e.NewExpression, func);
						var i = Transform(e.Initializers,  p =>
						{
							var args = Transform(p.Arguments, func);
							return args != p.Arguments? Expression.ElementInit(p.AddMethod, args): p;
						});

						return n != e.NewExpression || i != e.Initializers ?
							Expression.ListInit((NewExpression)n, i) :
							expr;
					}

				case ExpressionType.MemberAccess:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (MemberExpression)expr;
						var ex = Transform(e.Expression, func);

						return ex != e.Expression ? Expression.MakeMemberAccess(ex, e.Member) : expr;
					}

				case ExpressionType.MemberInit:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						Func<MemberBinding,MemberBinding> modify = null; modify = b =>
						{
							switch (b.BindingType)
							{
								case MemberBindingType.Assignment:
									{
										var ma = (MemberAssignment)b;
										var ex = Transform(ma.Expression, func);

										if (ex != ma.Expression)
											ma = Expression.Bind(ma.Member, ex);

										return ma;
									}

								case MemberBindingType.ListBinding:
									{
										var ml = (MemberListBinding)b;
										var i  = Transform(ml.Initializers, p =>
										{
											var args = Transform(p.Arguments, func);
											return args != p.Arguments? Expression.ElementInit(p.AddMethod, args): p;
										});

										if (i != ml.Initializers)
											ml = Expression.ListBind(ml.Member, i);

										return ml;
									}

								case MemberBindingType.MemberBinding:
									{
										var mm = (MemberMemberBinding)b;
										var bs = Transform(mm.Bindings, modify);

										if (bs != mm.Bindings)
											mm = Expression.MemberBind(mm.Member);

										return mm;
									}
							}

							return b;
						};

						var e  = (MemberInitExpression)expr;
						var ne = Transform(e.NewExpression, func);
						var bb = Transform(e.Bindings,      modify);

						return ne != e.NewExpression || bb != e.Bindings ?
							Expression.MemberInit((NewExpression)ne, bb) :
							expr;
					}

				case ExpressionType.New:
					{
						var ex = func(expr);
						if (ex != expr)
							return ex;

						var e = (NewExpression)expr;
						var a = Transform(e.Arguments, func);

						return a != e.Arguments ?
							e.Members == null ?
								Expression.New(e.Constructor, a) :
								Expression.New(e.Constructor, a, e.Members) :
							expr;
					}

				case ExpressionType.NewArrayBounds:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (NewArrayExpression)expr;
						var ex = Transform(e.Expressions, func);

						return ex != e.Expressions ? Expression.NewArrayBounds(e.Type, ex) : expr;
					}

				case ExpressionType.NewArrayInit:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (NewArrayExpression)expr;
						var ex = Transform(e.Expressions, func);

						return ex != e.Expressions ?
							Expression.NewArrayInit(e.Type.GetElementType(), ex) :
							expr;
					}

				case ExpressionType.TypeIs:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (TypeBinaryExpression)expr;
						var ex = Transform(e.Expression, func);

						return ex != e.Expression ? Expression.TypeIs(ex, e.Type) : expr;
					}

#if FW4 || SILVERLIGHT

				case ExpressionType.Block:
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (BlockExpression)expr;
						var ex = Transform(e.Expressions, func);
						var v  = Transform(e.Variables,   func);

						return ex != e.Expressions || v != e.Variables ? Expression.Block(e.Type, v, ex) : expr;
					}

#endif

				case ExpressionType.Constant : return func(expr);
				case ExpressionType.Parameter: return func(expr);

				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
					{
						var exp = func(expr);
						if (exp != expr)
							return exp;

						var e  = (ChangeTypeExpression)expr;
						var ex = Transform(e.Expression, func);

						if (ex == e.Expression)
							return expr;

						if (ex.Type == e.Type)
							return ex;

						return new ChangeTypeExpression(ex, e.Type);
					}
			}

			throw new InvalidOperationException();
		}

		#endregion

		#region Transform2

		static IEnumerable<T> Transform2<T>(ICollection<T> source, Func<T,T> func)
			where T : class
		{
			var modified = false;
			var list     = new List<T>();

			foreach (var item in source)
			{
				var e = func(item);
				list.Add(e);
				modified = modified || e != item;
			}

			return modified ? list : source;
		}

		static IEnumerable<T> Transform2<T>(ICollection<T> source, Func<Expression,TransformInfo> func)
			where T : Expression
		{
			var modified = false;
			var list     = new List<T>();

			foreach (var item in source)
			{
				var e = Transform(item, func);
				list.Add((T)e);
				modified = modified || e != item;
			}

			return modified ? list : source;
		}

		public static Expression Transform(this Expression expr, Func<Expression,TransformInfo> func)
		{
			if (expr == null)
				return null;

			switch (expr.NodeType)
			{
				case ExpressionType.Add:
				case ExpressionType.AddChecked:
				case ExpressionType.And:
				case ExpressionType.AndAlso:
				case ExpressionType.ArrayIndex:
#if FW4 || SILVERLIGHT
				case ExpressionType.Assign:
#endif
				case ExpressionType.Coalesce:
				case ExpressionType.Divide:
				case ExpressionType.Equal:
				case ExpressionType.ExclusiveOr:
				case ExpressionType.GreaterThan:
				case ExpressionType.GreaterThanOrEqual:
				case ExpressionType.LeftShift:
				case ExpressionType.LessThan:
				case ExpressionType.LessThanOrEqual:
				case ExpressionType.Modulo:
				case ExpressionType.Multiply:
				case ExpressionType.MultiplyChecked:
				case ExpressionType.NotEqual:
				case ExpressionType.Or:
				case ExpressionType.OrElse:
				case ExpressionType.Power:
				case ExpressionType.RightShift:
				case ExpressionType.Subtract:
				case ExpressionType.SubtractChecked:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (BinaryExpression)expr;
						var c = Transform(e.Conversion, func);
						var l = Transform(e.Left,       func);
						var r = Transform(e.Right,      func);

						return c != e.Conversion || l != e.Left || r != e.Right ?
							Expression.MakeBinary(expr.NodeType, l, r, e.IsLiftedToNull, e.Method, (LambdaExpression)c):
							expr;
					}

				case ExpressionType.ArrayLength:
				case ExpressionType.Convert:
				case ExpressionType.ConvertChecked:
				case ExpressionType.Negate:
				case ExpressionType.NegateChecked:
				case ExpressionType.Not:
				case ExpressionType.Quote:
				case ExpressionType.TypeAs:
				case ExpressionType.UnaryPlus:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (UnaryExpression)expr;
						var o = Transform(e.Operand, func);

						return o != e.Operand ?
							Expression.MakeUnary(expr.NodeType, o, e.Type, e.Method) :
							expr;
					}

				case ExpressionType.Call:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (MethodCallExpression)expr;
						var o = Transform(e.Object,    func);
						var a = Transform2(e.Arguments, func);

						return o != e.Object || a != e.Arguments ? 
							Expression.Call(o, e.Method, a) : 
							expr;
					}

				case ExpressionType.Conditional:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (ConditionalExpression)expr;
						var s = Transform(e.Test,    func);
						var t = Transform(e.IfTrue,  func);
						var f = Transform(e.IfFalse, func);

						return s != e.Test || t != e.IfTrue || f != e.IfFalse ?
							Expression.Condition(s, t, f) :
							expr;
					}

				case ExpressionType.Invoke:
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (InvocationExpression)expr;
						var ex = Transform(e.Expression, func);
						var a  = Transform2(e.Arguments,  func);

						return ex != e.Expression || a != e.Arguments ? Expression.Invoke(ex, a) : expr;
					}

				case ExpressionType.Lambda:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (LambdaExpression)expr;
						var b = Transform(e.Body,       func);
						var p = Transform2(e.Parameters, func);

						return b != e.Body || p != e.Parameters ? Expression.Lambda(ex.Expression.Type, b, p.ToArray()) : expr;
					}

				case ExpressionType.ListInit:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (ListInitExpression)expr;
						var n = Transform(e.NewExpression, func);
						var i = Transform2(e.Initializers,  p =>
						{
							var args = Transform2(p.Arguments, func);
							return args != p.Arguments? Expression.ElementInit(p.AddMethod, args): p;
						});

						return n != e.NewExpression || i != e.Initializers ?
							Expression.ListInit((NewExpression)n, i) :
							expr;
					}

				case ExpressionType.MemberAccess:
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (MemberExpression)expr;
						var ex = Transform(e.Expression, func);

						return ex != e.Expression ? Expression.MakeMemberAccess(ex, e.Member) : expr;
					}

				case ExpressionType.MemberInit:
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						Func<MemberBinding,MemberBinding> modify = null; modify = b =>
						{
							switch (b.BindingType)
							{
								case MemberBindingType.Assignment:
									{
										var ma = (MemberAssignment)b;
										var ex = Transform(ma.Expression, func);

										if (ex != ma.Expression)
											ma = Expression.Bind(ma.Member, ex);

										return ma;
									}

								case MemberBindingType.ListBinding:
									{
										var ml = (MemberListBinding)b;
										var i  = Transform(ml.Initializers, p =>
										{
											var args = Transform2(p.Arguments, func);
											return args != p.Arguments? Expression.ElementInit(p.AddMethod, args): p;
										});

										if (i != ml.Initializers)
											ml = Expression.ListBind(ml.Member, i);

										return ml;
									}

								case MemberBindingType.MemberBinding:
									{
										var mm = (MemberMemberBinding)b;
										var bs = Transform(mm.Bindings, modify);

										if (bs != mm.Bindings)
											mm = Expression.MemberBind(mm.Member);

										return mm;
									}
							}

							return b;
						};

						var e  = (MemberInitExpression)expr;
						var ne = Transform(e.NewExpression, func);
						var bb = Transform2(e.Bindings,      modify);

						return ne != e.NewExpression || bb != e.Bindings ?
							Expression.MemberInit((NewExpression)ne, bb) :
							expr;
					}

				case ExpressionType.New:
					{
						var ex = func(expr);
						if (ex.Stop || ex.Expression != expr)
							return ex.Expression;

						var e = (NewExpression)expr;
						var a = Transform2(e.Arguments, func);

						return a != e.Arguments ?
							e.Members == null ?
								Expression.New(e.Constructor, a) :
								Expression.New(e.Constructor, a, e.Members) :
							expr;
					}

				case ExpressionType.NewArrayBounds:
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (NewArrayExpression)expr;
						var ex = Transform2(e.Expressions, func);

						return ex != e.Expressions ? Expression.NewArrayBounds(e.Type, ex) : expr;
					}

				case ExpressionType.NewArrayInit:
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (NewArrayExpression)expr;
						var ex = Transform2(e.Expressions, func);

						return ex != e.Expressions ?
							Expression.NewArrayInit(e.Type.GetElementType(), ex) :
							expr;
					}

				case ExpressionType.TypeIs :
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (TypeBinaryExpression)expr;
						var ex = Transform(e.Expression, func);

						return ex != e.Expression ? Expression.TypeIs(ex, e.Type) : expr;
					}

#if FW4 || SILVERLIGHT

				case ExpressionType.Block :
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (BlockExpression)expr;
						var ex = Transform2(e.Expressions, func);
						var v  = Transform2(e.Variables,   func);

						return ex != e.Expressions || v != e.Variables ? Expression.Block(e.Type, v, ex) : expr;
					}

#endif

				case ExpressionType.Constant : return func(expr).Expression;
				case ExpressionType.Parameter: return func(expr).Expression;

				case (ExpressionType)ChangeTypeExpression.ChangeTypeType :
					{
						var exp = func(expr);
						if (exp.Stop || exp.Expression != expr)
							return exp.Expression;

						var e  = (ChangeTypeExpression)expr;
						var ex = Transform(e.Expression, func);

						if (ex == e.Expression)
							return expr;

						if (ex.Type == e.Type)
							return ex;

						return new ChangeTypeExpression(ex, e.Type);
					}
			}

			throw new InvalidOperationException();
		}

		#endregion
*/
		#region Helpers

		static public Unwrap(this ex : Expression) : Expression
		{
			| Quote         (op)
			| ConvertExpr   (op) when !op.Type.IsEnum
			| ConvertChecked(op) when !op.Type.IsEnum => op.Unwrap()
			| ex                                      => ex
		}
/*
		static public Dictionary<Expression,Expression> GetExpressionAccessors(this Expression expression, Expression path)
		{
			var accessors = new Dictionary<Expression, Expression>();

			expression.Path(path, (e,p) =>
			{
				switch (e.NodeType)
				{
					case ExpressionType.Call           :
					case ExpressionType.MemberAccess   :
					case ExpressionType.New            :
						if (!accessors.ContainsKey(e))
							accessors.Add(e, p);
						break;

					case ExpressionType.Constant       :
						if (!accessors.ContainsKey(e))
							accessors.Add(e, Expression.Property(p, ReflectionHelper.Constant.Value));
						break;

					case ExpressionType.ConvertChecked :
					case ExpressionType.Convert        :
						if (!accessors.ContainsKey(e))
						{
							var ue = (UnaryExpression)e;

							switch (ue.Operand.NodeType)
							{
								case ExpressionType.Call           :
								case ExpressionType.MemberAccess   :
								case ExpressionType.New            :
								case ExpressionType.Constant       :

									accessors.Add(e, p);
									break;
							}
						}

						break;
				}
			});

			return accessors;
		}

		static public Expression GetRootObject(this Expression expr)
		{
			if (expr == null)
				return null;

			switch (expr.NodeType)
			{
				case ExpressionType.Call         :
					{
						var e = (MethodCallExpression)expr;

						if (e.Object != null)
							return GetRootObject(e.Object);

						if (e.Arguments != null && e.Arguments.Count > 0 && e.IsQueryable())
							return GetRootObject(e.Arguments[0]);

						break;
					}

				case ExpressionType.MemberAccess :
					{
						var e = (MemberExpression)expr;

						if (e.Expression != null)
							return GetRootObject(e.Expression.Unwrap());

						break;
					}
			}

			return expr;
		}

		static public List<Expression> GetMembers(this Expression expr)
		{
			if (expr == null)
				return new List<Expression>();

			List<Expression> list;

			switch (expr.NodeType)
			{
				case ExpressionType.Call         :
					{
						var e = (MethodCallExpression)expr;

						if (e.Object != null)
							list = GetMembers(e.Object);
						else if (e.Arguments != null && e.Arguments.Count > 0 && e.IsQueryable())
							list = GetMembers(e.Arguments[0]);
						else
							list = new List<Expression>();

						break;
					}

				case ExpressionType.MemberAccess :
					{
						var e = (MemberExpression)expr;

						list = e.Expression != null ? GetMembers(e.Expression.Unwrap()) : new List<Expression>();

						break;
					}

				default                          :
					list = new List<Expression>();
					break;
			}

			list.Add(expr);

			return list;
		}
*/

		static public IsQueryable(this method : MethodCallExpression) : bool
		{
			def type = method.Method.DeclaringType;
			type == typeof(Queryable) || type == typeof(Enumerable) ////////////////////|| type == typeof(LinqExtensions);
		}

		static public IsQueryable(this method : MethodCallExpression, name : string) : bool
		{
			method.Method.Name == name && method.IsQueryable();
		}

		static public IsQueryable(this method : MethodCallExpression, params names : array[string]) : bool
		{
			when (method.IsQueryable())
				foreach (name in names)
					when (method.Method.Name == name)
						return true;
			false
		}

		static public GetLevelExpression(this expression : Expression, level : int) : Expression
		{
			def findLevel(ex : Expression, current : int) : Expression * int
			{
				def next(expr)
				{
					def (e,cur) = findLevel(expr, current);
					if (level == cur) (e, cur) else (ex, cur + 1)
				}

				match (ex)
				{
					| Call  (null, _, args) as call when call.IsQueryable() && args.Count > 0 => next(args[0])
					| Call  (null, _, _)
					| Member(null, _)    => (ex, current)
					| Call  (obj, _, _)  => next(obj)
					| Member(e, _)       => next(e.Unwrap())
					| _                  => (ex, current)
				}
			}

			def (expr,current) = findLevel(expression, 0);

			if (expr == null || current != level)
				throw InvalidOperationException();
			else
				expr
		}

		#endregion
	}
}
